SourceFile
	= ( UniversalStmt | TopLevelStmt )*
	;

UniversalStmt
	= VarDeclStmt
	| FlowControlStmt
	| SassDirectiveStmt
	;

TopLevelStmt
	= ModuleLoadStmt
	| ImportStmt
	| MixinDefStmt
	| FunctionDefStmt
	;

BlockLevelStmt
	= UniversalStmt
#	| CssStmt
	| ReturnStmt
	;

VarDeclStmt
	= Token.SassVar Token.Colon Expression Terminator
	;

FlowControlStmt
	= IfStmt
	| EachStmt
	| ForStmt
#	| WhileStmt
	;

IfStmt
	= Token.AtIf Expression Block ( ElseClause )*
	;

ElseClause
	= Token.AtElse ( Token.If Expression )? Block
	;

EachStmt
	= Token.AtEach
		( Token.SassVar )[Token.Comma]+
		Token.In
		Expression
		Block
	;

ForStmt
	= Token.AtFor
		Token.SassVar
		Token.From
		Expression
		( Token.Through | Token.To )
		Expression
		Block
	;

SassDirectiveStmt
	= ( Token.AtError | Token.AtWarn | Token.AtDebug )
		QuotedStringExpr
		Terminator
	;

ModuleLoadStmt
	= Token.AtUse
		QuotedStringExpr
		( Token.As ( Token.Ident | Token.Star ) )?
		Token.SemiColon
	;

ImportStmt
	= Token.AtImport StringLiteral Terminator
	;

MixinDefStmt
	= Token.AtMixin Token.Ident ( Parameters )? RuleBlock
	;

FunctionDefStmt
	= Token.AtFunction Token.Ident Parameters FunctionBody
	;

ReturnStmt
	= Token.AtReturn Expression
	;

Parameters
	= Token.LParen
		( Parameter
			( Token.Comma Parameter )*
			( Token.Comma | Token.Ellipsis )?
		)?
		Token.RParen
	;

Parameter
	= Token.SassVar ( Token.Colon Expression )?
	;

Block
	= Token.LBrace ( BlockLevelStmt )* Token.RBrace
	;

Expression
	= Token.SassVar
	| Literal
	;

Literal
	= StringLiteral
	| Token.BoolLiteral
	| Token.NullLiteral
	| Token.NumLiteral
	| Token.ColorLiteral
	;

StringLiteral
	= SQuotedStringLiteral | DQuotedStringLiteral
	;

SQuotedStringLiteral
	= Token.SQuote ( ~Token.SQuote )* Token.SQuote
	;

DQuotedStringLiteral
	= Token.DQuote ( ~Token.DQuote )* Token.DQuote
	;

Terminator
	= (?=> Token.RBrace ) Token.SemiColon?
	| Token.SemiColon
	;
